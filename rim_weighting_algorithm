import pprint, math as m, pyodbc

def calcFrequencies(responses):
'''Calculates frequencies for responses in a given 'column' '''
    frequencies = {}

    for response in responses:
        if response in frequencies.keys():
            frequencies[response] += 1
        else:
            frequencies[response] = 1

    return frequencies

def crosstabFrequencies(*responses):
'''Cross-tabulates responses for multiple 'columns', returns frequencies'''
    return calcFrequencies(list(zip(*responses)))

def aggregateCrosstabFrequencies(index):
'''Aggregates frequencies of responses for each 'column' in a crosstab. Column
in this case is the index positon in the crosstab key tuple'''
	frequencies = {}

	for t, frequency in currentCrosstab.items():

		if t[index] in frequencies.keys():
			frequencies[t[index]] += frequency
		else:
			frequencies[t[index]] = frequency

	return dict(sorted(frequencies.items()))

def frequenciesDifference(currentFrequencies, desiredFrequencies):
'''Calculates total difference between current and desired frequencies'''
	totalDiff = 0

	for currentFrequency, desiredFrequency in\
		zip(currentFrequencies.values(), desiredFrequencies.values()):
		totalDiff += abs(currentFrequency - desiredFrequency)

	return totalDiff

def calcDifferencePerCase(currentFrequencies, desiredFrequencies):
'''Calculates total difference between current and desired frequencies per case 
(this is used to check whether to perform another iteration)'''

	difference = frequenciesDifference(currentFrequencies, desiredFrequencies)

	sampleSize = sum(actualCrosstab.values())
	return difference / sampleSize

def calcWeights(currentFrequencies, desiredFrequencies):
'''Calculates weight factors as desiredFrequency/currentFrequency quotient'''
	weights = []

	for currentFrequency, desiredFrequency in\
		zip(currentFrequencies.values(), desiredFrequencies.values()):
		weights.append(desiredFrequency/currentFrequency)

	return weights

def applyWeights(index):
'''Applies weights to 'column'(index in tuple) in current crosstab'''
	for k, v in currentCrosstab.items():
		v = v*weights[int(k[index])-1]
		currentCrosstab[k] = v

class RimColumn:
''' Represents columns to be used in RIM Weighting. Contains the column of
responses, the actual frequencies, the desired frequencies and index '''
	rimColumns = []
	index = 0
	def __init__ (self, column, desiredFrequencies):
		RimColumn.rimColumns.append(self)
		self.index = RimColumn.index
		RimColumn.index+=1
		self.column = column
		self.desiredFrequencies = desiredFrequencies
		self.currentFrequencies = aggregateCrosstabFrequencies(self.index)

#Creates list for each 'column'
genders = []
ages = []
ageBins = []
deodorantUses = []

#Connects to SQL Server Database and retrieves data
connection = pyodbc.connect('Driver={SQL Server};'
					        'Server=.\sqlexpress;'
					        'Database=Nivea;'
					        'Trusted_connection=yes')

cursor = connection.cursor()
cursor.execute('SELECT * FROM Nivea.dbo.weighted_custom')

data = []
for row in cursor:
	data.append(row[6])

#Separates data by 'column' and appends these to respective 'column' lists
for i in data:
	x = i.split('&')

	for i in x:
		if 'Qs0' in i:
			genders.append(i.replace('Qs0=',''))
		elif 'Qs1_1' in i:
			ages.append(int(i.replace('Qs1_1=','')))
		elif 'Qs3' in i:
			deodorantUses.append(i.replace('Qs3=',''))

#Splits age data into age bins
for i in range(len(ages)):
    ageBins.append(m.floor((ages[i]-1)/10))

#Arbitrary desired frequency distributions
desiredAgeFrequencies = \
{'1':75, '2':400, '3':500, '4':300, '5':200, '6':29, '7':1}

desiredGenderFrequencies = \
{'1':700, '2':805}

#Assigns actual and initial current crosstabulation based on actual frequencies
currentCrosstab = crosstabFrequencies(ageBins, genders)
actualCrosstab = crosstabFrequencies(ageBins, genders)

#Creates 'RimColumns' for each 'column' of data
#NEED TO CREATE RIMCOLUMNS IN SAME ORDER AS CROSSTAB ORDER
ageRimColumn = RimColumn(ageBins, desiredAgeFrequencies)
genderRimColumn = RimColumn(genders, desiredGenderFrequencies)

#Assigns initial total diff between actual and desired frequencies per case
totalDifferencePerCase = 0
for column in RimColumn.rimColumns:
	totalDifferencePerCase += \
	calcDifferencePerCase(column.currentFrequencies,\
						  column.desiredFrequencies)

# Rim-Weighting Algorithm
iteration = 0
while totalDifferencePerCase > 0.00000000000000001:
	totalDifferencePerCase = 0

	#Calculates and applies weights to crosstab frequencies
	for rimColumn in RimColumn.rimColumns:
		weights = \
		calcWeights(rimColumn.currentFrequencies,rimColumn.desiredFrequencies)

		applyWeights(rimColumn.index)

		#Updates current freq to reflect newly weighted crosstab freq
		for rimColumn in RimColumn.rimColumns:
			rimColumn.currentFrequencies =\
			aggregateCrosstabFrequencies(rimColumn.index)

	#Calculates total difference per case at end of iteration
	for rimColumn in RimColumn.rimColumns:
		totalDifferencePerCase += \
		calcDifferencePerCase(rimColumn.currentFrequencies,\
							  rimColumn.desiredFrequencies)
		
	#Increases iteration and prints current iteration and difference per case
	iteration +=1
	print(f'\niteration: {iteration} \ntotal difference per case between '\
		  f'actual and desired frequencies: {totalDifferencePerCase}')

#Caclulates weights based on difference between actual and current crosstab freq
weights = calcWeights(actualCrosstab, currentCrosstab)

#Prints weights paired with corresponding crosstab key
crosstabWithWeights = dict(sorted(zip(actualCrosstab.keys(), weights)))
print(f'\nWeights calculated after {iteration} iterations:')
pprint.pprint(crosstabWithWeights)
