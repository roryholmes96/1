import math as m, pyodbc

def calcFrequencies(responses):
    '''Calculates frequencies for responses of a given variable'''
    frequencies = {}
    for response in responses:
        if response in frequencies.keys():
            frequencies[response] += 1
        else:
            frequencies[response] = 1
    return frequencies

def crosstabFrequencies(responses1, responses2):
    '''Cross-tabulates responses for 2 variables and returns frequencies'''
    return calcFrequencies(list(zip(responses1, responses2)))

def aggregateCrosstabFrequencies (crosstab):
	'''Aggregates frequencies of responses for each variable in a crosstab'''
	frequencies1 = {}
	frequencies2 = {}

	for (responses1, responses2), frequency in crosstab.items():
		if responses1 in frequencies1.keys():
			frequencies1[responses1] += frequency
		else:
			frequencies1[responses1] = frequency

		if responses2 in frequencies2.keys():
			frequencies2[responses2] += frequency
		else:
			frequencies2[responses2] = frequency

	return dict(sorted(frequencies1.items())),\
		   dict(sorted(frequencies2.items()))

def frequenciesDifference(currentFrequencies, desiredFrequencies):
	'''Calculates total difference between current and desired frequencies'''
	totalDiff = 0

	for currentFrequency, desiredFrequency in\
		zip(currentFrequencies.values(), desiredFrequencies.values()):
		
		totalDiff += abs(currentFrequency - desiredFrequency)

	return totalDiff

def calcDifferencePerCase(currentFrequencies1, desiredFrequencies1,\
 					      currentFrequencies2, desiredFrequencies2):
	'''Calculates total difference between current and desired frequencies 
	per case (this is used to check whether to perform another iteration)'''

	x = frequenciesDifference(currentFrequencies1,\
							  desiredFrequencies1)

	y = frequenciesDifference(currentFrequencies2,\
							  desiredFrequencies2)

	totalFrequenciesDifference = x+y
	sampleSize = sum(actualCrosstab.values())
	return totalFrequenciesDifference / sampleSize

def calcWeights(currentFrequencies, desiredFrequencies):
	'''Calculates weight factors as df/cf quotient'''
	weights = []

	for currentFrequency, desiredFrequency in\
		zip(currentFrequencies.values(), desiredFrequencies.values()):

		weights.append(desiredFrequency/currentFrequency)

	return weights

#Creates list for each variable
genders = []
ages = []
ageBins = []
deodorantUses = []

#Connects to SQL Server Database and retrieves data
connection = pyodbc.connect('Driver={SQL Server};'
					        'Server=.\sqlexpress;'
					        'Database=Nivea;'
					        'Trusted_connection=yes')

cursor = connection.cursor()
cursor.execute('SELECT * FROM Nivea.dbo.weighted_custom')

data = []
for row in cursor:
	data.append(row[6])

#Separates data by variable and appends these to respective variable lists
for i in data:
	x = i.split('&')

	for i in x:
		if 'Qs0' in i:
			genders.append(i.replace('Qs0=',''))
		elif 'Qs1_1' in i:
			ages.append(int(i.replace('Qs1_1=','')))
		elif 'Qs3' in i:
			deodorantUses.append(i.replace('Qs3=',''))

#Splits age data into age bins
for i in range(len(ages)):
    ageBins.append(m.floor((ages[i]-1)/10))

#Sets desired frequency distribution
desiredAgeFrequencies = \
{'1':75, '2':400, '3':500, '4':300, '5':200, '6':29, '7':1}

desiredGenderFrequencies = \
{'1':700, '2':805}

#Assigns actual and initial current crosstabulation based on actual frequencies
actualCrosstab = crosstabFrequencies(ageBins, genders)
currentCrosstab = crosstabFrequencies(ageBins, genders)

#Assigns initial current frequencies
currentAgeFrequencies, currentGenderFrequencies = \
aggregateCrosstabFrequencies(currentCrosstab)

#Assigns initial total difference between actual and desired freq per case
differencePerCase = \
calcDifferencePerCase(currentAgeFrequencies, desiredAgeFrequencies, \
					  currentGenderFrequencies, desiredGenderFrequencies)

# Rim-Weighting Algorithm
iteration = 0
while differencePerCase > 0.0000000000000001:

	#Updates current frequencies
	currentAgeFrequencies, currentGenderFrequencies = \
	aggregateCrosstabFrequencies(currentCrosstab)

	#Calculates weights based on gender
	weights = calcWeights(currentGenderFrequencies, desiredGenderFrequencies)

	#Applies weights based on gender and updates crosstab frequencies
	for k, v in currentCrosstab.items():
		v = v*weights[int(k[1])-1]
		currentCrosstab[k] = v

	#Updates current frequencies after weighting for age
	currentAgeFrequencies, currentGenderFrequencies = \
	aggregateCrosstabFrequencies(currentCrosstab)

	#Calculates weights based on age
	weights = calcWeights(currentAgeFrequencies, desiredAgeFrequencies)

	#Applies weights based on age and updates crosstab frequencies
	for k, v in currentCrosstab.items():
		v = v*weights[k[0]-1]
		currentCrosstab[k] = v

	#Updates current frequencies after weighting for gender
	currentAgeFrequencies, currentGenderFrequencies = \
	aggregateCrosstabFrequencies(currentCrosstab)

	#Updates difference per case at end of iteration
	differencePerCase = \
	calcDifferencePerCase(currentAgeFrequencies, desiredAgeFrequencies, \
						  currentGenderFrequencies, desiredGenderFrequencies)

	#Increases iteration and prints current iteration and difference per case
	iteration +=1
	print(f'iteration: {iteration} \n\
	total difference per case between actual and desired frequencies:'\
	f' {differencePerCase}')

weights = calcWeights(actualCrosstab, currentCrosstab)
print(f'\nWeights calculated after {iteration} iterations:\n{weights}')
